-----------------------------------------------------------------------------------------------------
docker 部署项目

在 /home 或 /opt 目录下运行 java -jar 时，JVM 内部 access() 系统调用失败，但 ls 明明能看到文件。
本质是：IcedTea 的 File.canRead() 或 Path.toFile().exists() 实现中，对某些路径做了错误的规范化处理，导致路径被“误判”为不存在。
openjdk:alpine这个版本存在问题


真实证据：这是社区公认的 IcedTea Bug
搜索关键词：

icedtea alpine unable to access jarfile
alpine java access enoent
OpenJDK8 Alpine path resolution bug

解决方法
✅ 推荐替代方案（按优先级排序）：
方案	                               优点	                   缺点
使用 /tmp + cp	                     简单、稳定、零成本	       临时文件需管理
换用 eclipse-temurin:8-jre-alpine	   官方 OpenJDK，无此 Bug	 需要替换私有镜像
使用 alpine:3.19 + openjdk:8-jre	   更稳定	                 体积稍大
⚠️ 修改 IcedTea 源码重编	彻底解决	太复杂，不推荐
💡 强烈建议：
如果你们能接受，把 nexus.crm.huawei.com:51443/gdtimes/openjdk:alpine 换成 eclipse-temurin:8-jre-alpine，
这才是根治之道。

-----------------------------------------------------------------------------------------------------------------
很好，这个问题非常经典！在 Kubernetes（K8s）中，`Deployment` 和 `Service` 是两个核心组件，它们分工明确、协同工作，下面我用“人话”+“比喻”帮你彻底搞懂它们的区别和作用。

---

## 🌟 一句话总结：

- **Deployment**：负责“**怎么跑应用**” —— 管理 Pod 的生命周期、版本更新、扩缩容。
- **Service**：负责“**怎么找到应用**” —— 给外面一个稳定的入口，让请求能打到后端的 Pod。

---

## 🧱 1. Deployment：应用的“指挥官”

### ✅ 作用：
- 定义你的应用应该运行多少个副本（Pod）。
- 控制 Pod 的部署方式（滚动更新、蓝绿发布等）。
- 自动恢复崩溃的 Pod。
- 支持版本回滚（比如上线出错，一键回到上一版）。

### 📌 比喻：
> 就像一个“工厂生产线”的调度系统。  
> 你想生产 3 台机器人（Pod），Deployment 就安排 3 个工人（Pod）干活，  
> 工人死了它自动叫新工人来补位，  
> 想升级成新款机器人？它也能平滑换装，不中断生产。

### ✅ 典型配置片段：
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app
          image: nginx:latest
          ports:
            - containerPort: 80
```

---

## 🌐 2. Service：应用的“门牌号 + 门卫”

### ✅ 作用：
- 给一组 Pod 提供一个 **固定的访问地址（ClusterIP / NodePort / LoadBalancer）**。
- 实现负载均衡：请求会被分发到后端多个 Pod 上。
- 即使 Pod 换了 IP（比如重启了），Service 依然能正确转发流量。

### 📌 比喻：
> 就像一个公司大楼的前台电话号码。  
> 你打电话给 “总机 8080”（Service），不管里面哪个员工（Pod）在上班，  
> 总机会把电话转给正在值班的人，  
> 员工换了也不怕，只要号码不变就行。

### ✅ 典型配置片段（ClusterIP 类型）：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app         # 关联 Deployment 创建的 Pod
  ports:
    - protocol: TCP
      port: 80          # Service 的对外端口
      targetPort: 80    # Pod 内部端口
  type: ClusterIP       # 只在集群内部访问
```

> 之后你可以通过 `my-app-service.default.svc.cluster.local` 或 `http://<cluster-ip>:80` 访问这个应用。

---

## 🔗 它们是怎么配合的？

```
外部请求 → Service (稳定入口) → 路由到多个 Pod → Deployment (管理这些 Pod)
```

✅ 比如：
- 你部署了一个 Web 应用，用 `Deployment` 控制 3 个 Nginx Pod。
- 用 `Service` 给这 3 个 Pod 提供一个统一的访问地址 `my-web-svc:80`。
- 外面的浏览器访问 `http://my-web-svc`，就能被自动分发到任意一个健康的 Pod。

---

## 🔄 补充：其他类型 Service

| 类型 | 用途 |
|------|------|
| `ClusterIP` | 默认，只在集群内部访问（适合微服务间通信） |
| `NodePort` | 在每个节点开放一个端口，外部可访问（测试用） |
| `LoadBalancer` | 自动创建云服务商的负载均衡器（生产推荐） |

---

## ✅ 总结一句话：

> **Deployment 是“管你怎么跑”，Service 是“管你怎么被找到”。**
>
> 没有 Deployment，你没法可靠地运行应用；  
> 没有 Service，别人根本找不到你。

---

🎯 建议实践：
```bash
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl get pods,svc
```
然后访问 Service 的 IP 或域名，看看是不是真能通！

需要我给你写个完整的 `deployment + service` 示例吗？随时说~ 😄























查看kafka是否出问题流程
第一步：看 Pod 状态 —— “病人有没有心跳？”
kubectl get po -n 154bcoc-yj |grep kafka
第二步：看 Kafka 是否监听端口 —— “耳朵能不能听见？”
kubectl exec -it kafka-statefulset-1-0 -n 154bcoc-yj -- netstat -tuln | grep 9092
tcp        0      0 10.244.8.212:9092       0.0.0.0:*               LISTEN
第三步：检查 advertised.listeners 配置 —— “门牌号有没有写对？”
kubectl exec -it kafka-statefulset-1-0 -n 154bcoc-yj -- cat /opt/kafka/config/server.properties | grep advertised.listeners
advertised.listeners=PLAINTEXT://kafka-statefulset-1-0.kafka-service-1.154bcoc-yj.svc.cluster.local:9092
第四步：检查 Service 是否正常 —— “快递能不能送到门？”
kubectl get svc -n 154bcoc-yj |grep kafka
kafka-service-1                ClusterIP      10.105.23.118    <none>                        9092/TCP                                        2y169d
kafka-service-2                ClusterIP      10.101.105.237   <none>                        9092/TCP                                        2y169d
kafka-service-3                ClusterIP      10.99.241.6      <none>                        9092/TCP                                        2y169d
第五步：客户端能否连上？—— “快递员能敲门吗？”
kubectl exec -it <你的客户端Pod名> -n <命名空间> -- /bin/sh
第六步：查看 Kafka 日志中的关键错误 —— “病人到底哪里痛？”
kubectl logs kafka-0 -n <你的命名空间> --tail=100
第七步：检查 Kafka 集群状态（如果有多个 Broker）—— “团队有没有协作？”
kubectl exec -it kafka-0 -n <你的命名空间> -- /bin/bash
kafka-broker-api-versions.sh --bootstrap-server localhost:9092




